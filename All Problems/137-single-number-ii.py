#!/usr/bin/env python
# encoding: utf-8
# @Time:2020/10/7 9:22
# @Author:JiahangGu
from typing import List


class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        """
        如果可以使用额外空间，使用一个数组存储每个数字每一位的出现次数，将和模3得到的结果即为出现
        1次的数字的二进制表示。但这里要求不能使用额外空间。
        首先，要求出唯一一个出现三次的数字，考虑到位运算中异或操作可以使出现偶数次的数字变为0，本题肯定要使用
        异或（因为与或非都不会产生0），但异或可以检测出出现奇数次的数字，这里是1和3均为奇数，只靠异或是无法判断的，
        所以需要区分1次和3次。
        区分思路是使用两个位掩码，one和two表示出现一次和两次的数字。
        之前出现过两次的，这次再出现就是三次，即three= two & x
        之前出现过两次的这次没出现，就是两次，以及之前出现一次的，这次再出现，也是出现了两次,two = (two & ~x) | (one & x)
        统计记录中出现了奇数次的，并清除其中出现三次的，这样ones里只记录出现了一次的，one = one ^ x, one &= ~three
        这里对上述提到的位运算原理进行解析。首先,one,two,three分别记录了出现1次、2次和3次的数字。此外还需要一个预备知识是，
        与、或、异或满足交换律。这样我们可以设想给定的数组是按照相同数字在一起排列好的，因为要用位运算而满足交换律。
        数字与本身与的结果还是该数字，如果数字出现2次，那么two记录该数字，再&x一定可以得到本身，这样就得到了出现三次的数字
        计算出现两次的数字，首先是已经出现2次且当前数字不是的情况，two&~x表明x的任何位数在two记录的数字中从未出现，而one&x和上行
        类似，通过与操作保留原数字，达到记录该数字次数+1的效果。
        最后是一次，0与任何数异或还是该数，所以有one^x，并且要从中去除出现三次的数字，和上行一样，对three取反得到three任意位数不出现的数字，
        然后与one与操作即可去除三次的数字。
        :param nums:
        :return:
        """
        # one, two = 0, 0
        # for num in nums:
        #     three = two & num
        #     two = (two & ~num) | (one & num)
        #     one = one ^ num
        #     one &= ~three
        # return one
        """
        官方题解看不懂，参阅大佬的题解https://leetcode-cn.com/problems/single-number-ii/solution/luo-ji-dian-lu-jiao-du-xiang-xi-fen-xi-gai-ti-si-l/
        才发现是个状态机问题。
        首先题目要找到一种逻辑操作，设为*，要满足1*1*1=0,0*1=1*0=1.可以想到，要记录的状态为出现0次，1次和2次。假设选择00,01,10表示，
        那么状态转移可以写为：输入是0，三种状态保持不变，输入是1（即01），状态迁移，00->01,01->10,10->00（三次的要归0）
        然后可以列出如下真值表
        XY      Z       Xnew        Ynew
        00      0       0           0
        01      0       0           1
        10      0       1           0
        00      1       0           1
        01      1       1           0
        10      1       0           0
        对于Y的逻辑表达式就是取Ynew=1的行，然后用或联系。即Ynew = ~X & ~Y & Z + ~X & Y & ~Z，化简后可得Ynew = ~X & (Y ^ Z)
        并将Ynew代入到Xnew的求解表达式中可得Xnew = ~Ynew & (X ^ Z)。
        则最后出现3次的数字都成为0，出现1次的都成为1（01），所以最后返回状态Y即为答案
        """
        x, y = 0, 0
        for z in nums:
            y = ~x & (y ^ z)
            x = ~y & (x ^ z)
        return y


s = Solution()
print(s.singleNumber([2,2,3,2]))
