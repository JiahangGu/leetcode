问题描述：三个和尚和三个妖怪要利用唯一一条小船过河，小船一次只能载两个人，且河的两岸只要妖怪数量大于和尚数量，妖怪就会吃掉和尚，
现在找一种过河的方案，保证都能过河且和尚不会被妖怪吃掉。
使用穷举法，首先定义问题的解，并分析解空间的范围和拓扑结构，然后根据空间范围和拓扑结构设计遍历搜索算法。

问题的解是所有和尚和妖怪都到河对岸。由于河岸以及河对岸只需要记录和尚和妖怪的个数，所以可以使用4个数字记录当前状态，分别表示河岸的和尚，
河岸的妖怪，对岸的和尚和对岸的妖怪。此外还有小船的位置应该在河对岸。[0,0,3,3,1]表示解空间，初始状态为[3,3,0,0,0]。其中
最后一位数字0表示在河岸，1表示在对岸。

定义状态转换过程需要考虑船的位置和妖怪和尚的数量限制。比如船可以走到对岸也可以回来，每次可以带不同数量的和尚和妖怪。考虑到船一次两个人，
则一共有10种动作：
一个妖怪过河
两个妖怪过河
一个和尚过河
两个和尚过河
一个妖怪一个和尚过河
一个妖怪返回
两个妖怪返回
一个和尚返回
两个和尚返回
一个妖怪一个和尚返回
这10种动作应该有统一的表达来减少if else的个数，提高代码的可读性。所以可以使用[go_or_back, monster_num, monk_num]表示一个动作，
第一个表示船的方向，第二个表示所带妖怪的数量，如果是负数则表示从本地移动到河对岸。

算法：从初始状态开始，遍历所有可能的动作，得到对应下一个状态，如果该状态没有访问过，标记已访问，并进入深层递归。如果到达解空间，则可以记录
解的路径并输出。