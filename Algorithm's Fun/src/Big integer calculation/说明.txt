大整数计算作为一个常见的问题用于解决计算结果溢出的问题。书中指出为了CPU处理数据更高效而使用2^32进制数字，但在这里为了普用性，还是使用10进制。
大整数计算通常使用字符串或数组记录大整数，其中字符串优势为输出方便、易于被人明白理解，但在处理需要逐位换算为数字，并将结果换算为字符，效率很低。用数组
则刚好相反。在这里选择数组进行运算，一方面符合大数库的流行趋势，另一方面提升效率。

加减乘都类似，只需要记录进位或借位的信息，并处理异号问题，而除法和模操作稍显特殊，需要用试商（竖式除法）法加快减的过程提高效率。

大整数乘方则利用快速幂和大整数乘法解决。
假设求a^9，则可以拆分成a^8 * a, a^8 = a^4 * a^4, a^4 = a^2 * a^2, a^2 = a * a，在计算时，假设临时变量t=a，结果res=1，9的二进制为1001,
最低位1，有res=r*t, t=t^2, 然后低位0，t=t^2, 然后低位0,t=t^2，然后低位1有res=res*t, t=t^2，最终返回res即可，且上述的乘方过程刚好和拆分的
结果一致。

此外还有大整数的最大公约数和最小公倍数、大整数求模的逆元
最大公约数:gcd(a, b) = gcd(b, a % b)
最小公倍数除了a*b//gcd(a,b)之外，还可以累加a直到a可以被b整除，但效率低。

扩展欧几里得算法：假设方程为ax+by=c，如果c是gcd(a,b)的整数倍，方程有多组解，推导过程如下
gcd(a,b)=gcd(b, a%b)代入到ax+by=gcd(a,b)
ax+by = gcd(a.b)=gcd(b, a%b)=bx'+(a%b)y'
反复代入会得到a%b=0，则原方程为ax'+by'=gcd(a,0)
令x'=1, y'=0即可，再经过上述代入过程反向递推出方程的解。
a%b=a-(a//b)*b，反向递推一次后
ax+by=bx'+(a%b)y'=bx'+(a-(a//b)*b)y'=ay'+b(x'-(a//b)y')，
根据恒等关系得到
x=y'
y=x'-(a//b)*y'
反复递推即可得到原解。
还可以用于求解同余方程
ax=b(mod n)
当且仅当gcd(a,n)|b时方程有整数解，且有gcd(a,n)个整数解。如果gcd(a,n)=1只有1个整数解，若b也=1则成为a的乘法逆元a^-1。
